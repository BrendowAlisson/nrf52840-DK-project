# nrf52840-DK-project
Este projeto foi desenvolvido para uma Placa de Desenvolvimento nrf52840-DK com Zephyr RTOS 2.7.1 .
A aplicação dele é que há dois botões (Botão 1 e Botão 2) em que quando não estão pressionados nada acontece. Entretanto quando o Botão 1 é pressionado, deve piscar o LED1 a cada 500 us, além de ler um contador I2C (S-35770) conectado na placa com a maior frequência suportada.
Já quando o Botão 2 é pressionado, deve acender o LED2 imediatamente e deve permanecer ligado enquanto o Botão 2 é pressionado.
Caso o Botão 1 e Botão 2 sejam apertados juntos, a aplicação deve esperar a soltura de quem foi pressionado primeiro para realizar a tarefa do segundo. Uma exceção vai ser o piscar do LED1 que deve ser executada toda vez.
Por fim, quando o pino conectado ao LOOP da S-35770 for mudado de sinal lógico, deve resetar o contador.

Como não possuo essa placa de desenvolvimento em minhas mãos, optei por testar a lógica do código em um Arduino UNO. Onde coloquei dois botões nas portas digitais do Arduino e utilizei da mesma lógica usada na nrf52840-DK, sendo a diferença as sintaxes feitas em cada código de programação.

Os botões usados no código foram os próprios botões da nrf52840-DK, sendo eles: Botão 1 (P0.11) e Botão 2 (P0.12). Além disso, os LEDS utilizados também encontram-se na placa: LED 1 (P0.13) e LED 2 (P0.14). [1](https://docs.zephyrproject.org/2.7.1/boards/arm/nrf52840dk_nrf52840/doc/index.html)

Para encontrar as configurações dos pinos foi usado da API de Devicetree disponibilizado pelo Zephyr no GitHub [2](https://github.com/nrfconnect/sdk-zephyr/blob/main/boards/arm/nrf52840dk_nrf52840/nrf52840dk_nrf52840.dts). Deste modo, é possível usar esta API encontrar as portas através dos comandos DT_ALIAS, DT_LABEL e DT_NODELABEL[3](https://docs.zephyrproject.org/latest/reference/devicetree/api.html). Em seguida foi criado um struct para as GPIOs com as suas localizações na API [4](https://docs.zephyrproject.org/latest/reference/peripherals/gpio.html). Outro fato importante é saber o endereço do slave S-35770 para fazer uso do I2C, quando é analisado o datasheet é possível ver que o endereço é "00110010" ou "0x32" em hexadecimal. Depois de construido todas as struct de gpio_dt_spec[5](https://docs.zephyrproject.org/apidoc/latest/structgpio__dt__spec.html) para os botões e leds, foi criado struct device[6](https://docs.zephyrproject.org/apidoc/latest/structdevice.html) para os pinos de I2C, LOOP e RESET. Por conseguinte, foi configurado as portas como saída (LEDS e RESET) e entradas (BOTÕES e LOOP). Para as GPIOs configuradas como entradas utilizou-se do método de pull up para não ter problema com entrada de dados flutuantes. [4](https://docs.zephyrproject.org/latest/reference/peripherals/gpio.html)
