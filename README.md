# nrf52840-DK-project
Este projeto foi desenvolvido para uma Placa de Desenvolvimento nrf52840-DK com Zephyr RTOS 2.7.1 . O desafio dado para esse projeto foi:
"O projeto deve ter dois botões (Botão 1 e Botão 2) em que quando não estão pressionados nada acontece. Entretanto quando o Botão 1 é pressionado, deve piscar o LED1 a cada 500 us, além de ler um contador I2C (S-35770) conectado na placa com a maior frequência suportada.
Já quando o Botão 2 é pressionado, deve acender o LED2 imediatamente e deve permanecer ligado enquanto o Botão 2 é pressionado.
Caso o Botão 1 e Botão 2 sejam apertados juntos, a aplicação deve esperar a soltura de quem foi pressionado primeiro para realizar a tarefa do segundo. Uma exceção vai ser o piscar do LED1 que deve ser executada toda vez.
Por fim, quando o pino conectado ao LOOP da S-35770 for mudado de sinal lógico, deve resetar o contador.
A aplicação deve também mostrar todas as suas ações. Você deve usar Kconfig symbols para remover todas as operações de contador para um cenário em que o aplicativo seria compilado e testado sem o contador anexado ao DK."

Como não possuo essa placa de desenvolvimento em minhas mãos, optei por testar a lógica do código em um Arduino UNO. Onde coloquei dois botões nas portas digitais do Arduino e utilizei da mesma lógica usada na nrf52840-DK, sendo a diferença as sintaxes feitas em cada código de programação.

Os botões usados no código foram os próprios botões da nrf52840-DK, sendo eles: Botão 1 (P0.11) e Botão 2 (P0.12). Além disso, os LEDS utilizados também encontram-se na placa: LED 1 (P0.13) e LED 2 (P0.14). [1](https://docs.zephyrproject.org/2.7.1/boards/arm/nrf52840dk_nrf52840/doc/index.html)

Para encontrar as configurações dos pinos foi usado da API de Devicetree disponibilizado pelo Zephyr no GitHub [2](https://github.com/nrfconnect/sdk-zephyr/blob/main/boards/arm/nrf52840dk_nrf52840/nrf52840dk_nrf52840.dts). Deste modo, é possível usar esta API encontrar as portas através dos comandos DT_ALIAS, DT_LABEL e DT_NODELABEL[3](https://docs.zephyrproject.org/latest/reference/devicetree/api.html). Em seguida foi criado um struct para as GPIOs com as suas localizações na API [4](https://docs.zephyrproject.org/latest/reference/peripherals/gpio.html). Outro fato importante é saber o endereço do slave S-35770 para fazer uso do I2C, quando é analisado o datasheet é possível ver que o endereço é "00110010" ou "0x32" em hexadecimal. Depois de construido todas as struct de gpio_dt_spec [5](https://docs.zephyrproject.org/apidoc/latest/structgpio__dt__spec.html) para os botões e leds, foi criado struct device [6](https://docs.zephyrproject.org/apidoc/latest/structdevice.html) para os pinos de I2C, LOOP e RESET. Por conseguinte, foi configurado as portas como saída (LEDS e RESET) e entradas (BOTÕES e LOOP). Para as GPIOs configuradas como entradas utilizou-se do método de pull up para não ter problema com entrada de dados flutuantes.

Após configurado cada porta lógica, foi criado uma variável que terá o valor do pino de TOGGLE e um flag que terá o mesmo valor inicial. Deste modo, haverá uma condição que quando o valor do pino TOGGLE for diferente da flag TOGGLE irá setar o pino RESET para 0, já que no datasheet da S-35770 é possível ver que seu contador reseta quando há uma entrada lógica sendo BAIXA. Desse modo, é completado: ~~"Por fim, quando o pino conectado ao LOOP da S-35770 for mudado de sinal lógico, deve resetar o contador"~~ 

Há também uma condição que se não houver um device na porta I2C, faz com que a função main termine. Entretanto, caso exista, a programação continua e manda uma mensagem para o debug através da função printk [7](https://docs.zephyrproject.org/apidoc/latest/printk_8h.html#a768a7dff8592b69f327a08f96b00fa54). Sendo esse também um dos requisitos do desafio: ~~"A aplicação deve também mostrar todas as suas ações."~~.
Quando encontrado o dispositivo I2C, ele é configurado com a velocidade ULTRA [8](https://docs.zephyrproject.org/latest/reference/peripherals/i2c.html#c.I2C_SPEED_ULTRA). Completando: ~~"lém de ler um contador I2C (S-35770) conectado na placa com a maior frequência suportada."~~

Em seguida, foi criado um while(true) onde há os estados dos botões (se estão em nível lógico ALTO ou BAIXO), setado o pino RESET em ALTO e o estado do pino toggle. Há diversas condições nesse while, uma delas é quando um botão é apertado primeiro faz com que mude a ordem em um vetor chamado posição. Dessa forma, quando o botão 1 é pressionado primeiro, faz com que seja realizado as suas atividades como: blinkar o LED e ler o contador I2C [9](https://docs.zephyrproject.org/latest/reference/peripherals/i2c.html#c.i2c_reg_read_byte) e caso o botão 2 seja pressionado enquanto o botão 1 já está apertado, a condição verifica no vetor posição quem foi o primeiro a ser apertado e espera ele ser solto para realizar a ação do segundo. O mesmo acontece caso o botão 2 seja apertado primeiro e depois o botão 1 segundo. Uma exceção é o blink que apenas depende de pressionar o botão 1 para realizar essa tarefa.
Essa parte do código foi testada em um Arduino UNO, como falada no início.

Com isso foi concluído: ~~"A aplicação dele é que há dois botões (Botão 1 e Botão 2) em que quando não estão pressionados nada acontece. Entretanto quando o Botão 1 é pressionado, deve piscar o LED1 a cada 500 us, além de ler um contador I2C (S-35770) conectado na placa com a maior frequência suportada.
Já quando o Botão 2 é pressionado, deve acender o LED2 imediatamente e deve permanecer ligado enquanto o Botão 2 é pressionado.
Caso o Botão 1 e Botão 2 sejam apertados juntos, a aplicação deve esperar a soltura de quem foi pressionado primeiro para realizar a tarefa do segundo. Uma exceção vai ser o piscar do LED1 que deve ser executada toda vez."

Por fim, foi compilado o código através do comando :
west build -b nrf52840dk_nrf52840 -t guiconfig 
Deste modo, é aberto o Kconfig interativo [10](https://docs.zephyrproject.org/latest/guides/build/kconfig/menuconfig.html) e nele é possível desativar os timers da placa, concluindo a última etapa do desafio: ~~"Você deve usar Kconfig symbols para remover todas as operações de contador para um cenário em que o aplicativo seria compilado e testado sem o contador anexado ao DK."~~


